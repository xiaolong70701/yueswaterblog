---
title: "股票數據預處理與雙均線策略"
image: trade preview.png
lang: en
description: |
    
date: "2023-07-23"
draft: FALSE
citation:
  url: https://yueswater-blog.netlify.app/posts/2023-07-23-trading-preprocessing-and-dual-MA/
categories: [macroeconomics]
---

## 數據預處理

我們使用 `yfinance` 這個爬蟲套件，可以抓取 [Yahoo奇摩股市](https://tw.stock.yahoo.com/)上的股票資料，包含日期、開盤價、收盤價、最低/高價、交易量等。此外，我們使用 `pandas` 幫助我們進行一些數據處理。

```{python}
import yfinance as yf
import pandas as pd
```

### 獲取資料與保存資料

假設我們想要看台積電(2330.TW)從 2020 年 1 月 1 日至 2023 年 1 月 1 日的股票資訊，我們使用 `yf.download("股票代碼", "起始日期", "結束日期")`獲取資料。

```{python}
df = yf.download("2330.tw", "2020-01-01", "2023-01-01")
```

獲取數據後，我們一般會先查看資料是否正確：

```{python}
df.head(6) # 查看 6 筆資料
```

如果我們想要將數據保存下來，可以使用以下方式：

```{python}
df.to_csv("2330.TW.csv")
```

為了後續處理之便，我們將剛剛儲存的資料讀取進來：

```{python}
# 讀取檔案
df = pd.read_csv("2330.TW.csv")
```

### 資料型別

由於我們之後需要做一些計算，因此我們必須確認每筆資料
是否為可以計算的型別。我們以開盤價為例：

```{python}
# 逐一檢查型別
df['Open'].dtype

# 一次檢查所有欄位型別
df.info()
```

其結果為 `float64`，是可以進行計算的型別。

接下來我們要將日期先轉換為 `Python` 中可以進行計算的日期格式，接著將日期變成索引，以方便查找我們需要日期的數據。

```{python}
# 轉換格式
df['Date'] = pd.to_datetime(df['Date'])

# 確認型別
df.info()

# 建立索引
df.set_index('Date', inplace = True)

# 查看結果
df.head(6)
```

### 簡單股票分析

首先我們先輸出所有收盤價比開盤價上漲 $3\%$ 以上的日期。用數學的方式表達即是
$$
\frac{\text{Close}_{t} - \text{Open}_{t}}{\text{Open}_{t}} > 0.03
$$

因此我們可以寫下以下程式碼：

```{python}
(df['Close'] - df['Open']) / df['Open'] > 0.03
```

可以發現回傳的值為布林值，因此可以作為行索引(row index)。

```{python}
# 根據行索引選取並輸出日期
df.loc[(df['Close'] - df['Open']) / df['Open'] > 0.03].index
```

我們即可得知這些日期符合我們的搜尋標準(searching standard)。

如果我們現在將搜尋標準改為輸出所有開盤價比前日收盤價小於 $2\%$ 的日期，我們可以用 `shift(1)` 來獲取前日的資料。以數學式表達即為

$$
\frac{\text{Open}_{t} - \text{Close}_{t-1}}{\text{Close}_{t-1}} < -0.02
$$

```{python}
# 根據行索引選取並輸出日期
df.loc[(df['Open'] - df['Close'].shift(1)) / df['Close'].shift(1) < -0.02].index
```
## 雙均線策略

均線（Moving Average）是一種技術分析工具，常用於股票、外匯和其他金融市場的分析。它是通過計算一段時間內的價格平均值來平滑價格走勢，從而消除價格波動的短期噪音，使得長期趨勢更加清晰可見。

均線的計算很簡單，只需將一段時間內的收盤價相加，然後除以該段時間的天數即可得到均線值。常見的均線包括 5 日均線、10 日均線、20 日均線、50 日均線和 200 日均線等。

不同的均線代表了不同時間範圍的平均價格，長期均線（如 200 日均線）較為平滑，反映了較長時間的趨勢變化，而短期均線（如 5 日均線）較為敏感，更能反映近期價格變動。

均線的計算方式有許多種，大致可以分為以下三類：

1. 簡單移動平均線(simple moving average，SMA)：
$$
\text{MA} = \frac{1}{n} \sum_{i=1}^{n} P_i
$$

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $n$代表計算均線的天數，$P_i$代表第 $i$ 天的價格。

2. 加權移動平均線(weighted moving average，WMA)：
$$
\text{WMA} = \frac{\sum_{i=1}^{n} w_i \cdot P_i}{\sum_{i=1}^{n} w_i}
$$

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$w_i$ 代表第 $i$ 天的權重。

3. 指數移動平均線(exponential moving average，EMA)：
$$
\text{EMA}_t = \alpha \cdot P_t + (1-\alpha) \cdot \text{EMA}_{t-1}
$$

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$\text{EMA}_t$ 代表第 $t$ 天的指數移動平均值，$\alpha$ 是平滑指數，通常取 $2/(n+1)$，其中 $n$ 為計算均線的天數。

### 求均線方式

假設我們分別要求算收盤價的 5 日均線與 10 日均線，我們可以透過 `rolling()` 與 `mean()` 這兩個函數進行以下操作：

```{python}
ma5 = df['Close'].rolling(5).mean()
ma30 = df['Close'].rolling(30).mean()
```

接著我們利用 `matplotlib` 套件繪製均線。

```{python}
# 引入套件
import matplotlib.pyplot as plt
%matplotlib inline
# 繪製均線
plt.plot(ma5, color = "#1c39bb")
plt.plot(ma30, color = "#d70062")
```

### 黃金交叉與死亡交叉

均線常用於分析股價走勢、判斷趨勢的轉折點以及進行交叉分析。當短期均線穿越長期均線時，被稱為「黃金交叉」，被認為是一個多頭信號，暗示著股價可能上漲；相反，當短期均線跌破長期均線時，被稱為「死亡交叉」，是一個空頭信號，暗示著股價可能下跌。我們根據黃金交叉與死亡交叉的定義建立自定義函式：

```{python}
def golden_death_cross_strategy(prices, short_window=5, long_window=30):
    # 計算短期均線和長期均線
    short_ma = pd.Series(prices).rolling(window=short_window, min_periods=1).mean()
    long_ma = pd.Series(prices).rolling(window=long_window, min_periods=1).mean()

    # 判斷黃金交叉和死亡交叉
    signals = pd.Series(0, index=range(len(prices)))  
    # 交叉信號：0表示無交叉，1表示黃金交叉，-1表示死亡交叉
    for i in range(1, len(prices)):
        if short_ma[i] > long_ma[i] and short_ma[i - 1] <= long_ma[i - 1]:
            signals[i] = 1  # 黃金交叉
        elif short_ma[i] < long_ma[i] and short_ma[i - 1] >= long_ma[i - 1]:
            signals[i] = -1  # 死亡交叉

    return signals

# 呼叫函數，得到交叉信號
closing_prices = df['Close']
signals = golden_death_cross_strategy(closing_prices)

# 輸出交叉信號
for i, signal in enumerate(signals):
    if signal == 1:
        print(f"黃金交叉：第 {i+1} 天")
    elif signal == -1:
        print(f"死亡交叉：第 {i+1} 天")

```

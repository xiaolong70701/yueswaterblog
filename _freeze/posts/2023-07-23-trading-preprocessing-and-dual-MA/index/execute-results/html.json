{
  "hash": "a6b4d68c2af032f3d043ae4cab9b36b7",
  "result": {
    "markdown": "---\ntitle: \"股票數據預處理與雙均線策略\"\nimage: trade preview.png\nlang: en\ndescription: |\n    \ndate: \"2023-07-23\"\ndraft: FALSE\ncitation:\n  url: https://yueswater.netlify.app/posts/notes/2023-07-23-trading-preprocessing-and-dual-MA/\ncategories: [macroeconomics]\n---\n\n## 數據預處理\n\n我們使用 `yfinance` 這個爬蟲套件，可以抓取 [Yahoo奇摩股市](https://tw.stock.yahoo.com/)上的股票資料，包含日期、開盤價、收盤價、最低/高價、交易量等。此外，我們使用 `pandas` 幫助我們進行一些數據處理。\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport yfinance as yf\nimport pandas as pd\n```\n:::\n\n\n### 獲取資料與保存資料\n\n假設我們想要看台積電(2330.TW)從 2020 年 1 月 1 日至 2023 年 1 月 1 日的股票資訊，我們使用 `yf.download(\"股票代碼\", \"起始日期\", \"結束日期\")`獲取資料。\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\ndf = yf.download(\"2330.tw\", \"2020-01-01\", \"2023-01-01\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\r[*********************100%***********************]  1 of 1 completed\n```\n:::\n:::\n\n\n獲取數據後，我們一般會先查看資料是否正確：\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\ndf.head(6) # 查看 6 筆資料\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Open</th>\n      <th>High</th>\n      <th>Low</th>\n      <th>Close</th>\n      <th>Adj Close</th>\n      <th>Volume</th>\n    </tr>\n    <tr>\n      <th>Date</th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>2020-01-02</th>\n      <td>332.5</td>\n      <td>339.0</td>\n      <td>332.5</td>\n      <td>339.0</td>\n      <td>313.791595</td>\n      <td>31754120</td>\n    </tr>\n    <tr>\n      <th>2020-01-03</th>\n      <td>344.0</td>\n      <td>345.0</td>\n      <td>335.5</td>\n      <td>339.5</td>\n      <td>314.254456</td>\n      <td>41811268</td>\n    </tr>\n    <tr>\n      <th>2020-01-06</th>\n      <td>333.0</td>\n      <td>334.5</td>\n      <td>332.0</td>\n      <td>332.0</td>\n      <td>307.312164</td>\n      <td>45343057</td>\n    </tr>\n    <tr>\n      <th>2020-01-07</th>\n      <td>332.5</td>\n      <td>333.0</td>\n      <td>326.5</td>\n      <td>329.5</td>\n      <td>304.998016</td>\n      <td>50879181</td>\n    </tr>\n    <tr>\n      <th>2020-01-08</th>\n      <td>325.0</td>\n      <td>333.0</td>\n      <td>325.0</td>\n      <td>329.5</td>\n      <td>304.998016</td>\n      <td>37567748</td>\n    </tr>\n    <tr>\n      <th>2020-01-09</th>\n      <td>335.0</td>\n      <td>337.5</td>\n      <td>333.5</td>\n      <td>337.5</td>\n      <td>312.403137</td>\n      <td>31481504</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n如果我們想要將數據保存下來，可以使用以下方式：\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\ndf.to_csv(\"2330.TW.csv\")\n```\n:::\n\n\n為了後續處理之便，我們將剛剛儲存的資料讀取進來：\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\n# 讀取檔案\ndf = pd.read_csv(\"2330.TW.csv\")\n```\n:::\n\n\n### 資料型別\n\n由於我們之後需要做一些計算，因此我們必須確認每筆資料\n是否為可以計算的型別。我們以開盤價為例：\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\n# 逐一檢查型別\ndf['Open'].dtype\n\n# 一次檢查所有欄位型別\ndf.info()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 734 entries, 0 to 733\nData columns (total 7 columns):\n #   Column     Non-Null Count  Dtype  \n---  ------     --------------  -----  \n 0   Date       734 non-null    object \n 1   Open       734 non-null    float64\n 2   High       734 non-null    float64\n 3   Low        734 non-null    float64\n 4   Close      734 non-null    float64\n 5   Adj Close  734 non-null    float64\n 6   Volume     734 non-null    int64  \ndtypes: float64(5), int64(1), object(1)\nmemory usage: 40.3+ KB\n```\n:::\n:::\n\n\n其結果為 `float64`，是可以進行計算的型別。\n\n接下來我們要將日期先轉換為 `Python` 中可以進行計算的日期格式，接著將日期變成索引，以方便查找我們需要日期的數據。\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\n# 轉換格式\ndf['Date'] = pd.to_datetime(df['Date'])\n\n# 確認型別\ndf.info()\n\n# 建立索引\ndf.set_index('Date', inplace = True)\n\n# 查看結果\ndf.head(6)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 734 entries, 0 to 733\nData columns (total 7 columns):\n #   Column     Non-Null Count  Dtype         \n---  ------     --------------  -----         \n 0   Date       734 non-null    datetime64[ns]\n 1   Open       734 non-null    float64       \n 2   High       734 non-null    float64       \n 3   Low        734 non-null    float64       \n 4   Close      734 non-null    float64       \n 5   Adj Close  734 non-null    float64       \n 6   Volume     734 non-null    int64         \ndtypes: datetime64[ns](1), float64(5), int64(1)\nmemory usage: 40.3 KB\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=7}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Open</th>\n      <th>High</th>\n      <th>Low</th>\n      <th>Close</th>\n      <th>Adj Close</th>\n      <th>Volume</th>\n    </tr>\n    <tr>\n      <th>Date</th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>2020-01-02</th>\n      <td>332.5</td>\n      <td>339.0</td>\n      <td>332.5</td>\n      <td>339.0</td>\n      <td>313.791595</td>\n      <td>31754120</td>\n    </tr>\n    <tr>\n      <th>2020-01-03</th>\n      <td>344.0</td>\n      <td>345.0</td>\n      <td>335.5</td>\n      <td>339.5</td>\n      <td>314.254456</td>\n      <td>41811268</td>\n    </tr>\n    <tr>\n      <th>2020-01-06</th>\n      <td>333.0</td>\n      <td>334.5</td>\n      <td>332.0</td>\n      <td>332.0</td>\n      <td>307.312164</td>\n      <td>45343057</td>\n    </tr>\n    <tr>\n      <th>2020-01-07</th>\n      <td>332.5</td>\n      <td>333.0</td>\n      <td>326.5</td>\n      <td>329.5</td>\n      <td>304.998016</td>\n      <td>50879181</td>\n    </tr>\n    <tr>\n      <th>2020-01-08</th>\n      <td>325.0</td>\n      <td>333.0</td>\n      <td>325.0</td>\n      <td>329.5</td>\n      <td>304.998016</td>\n      <td>37567748</td>\n    </tr>\n    <tr>\n      <th>2020-01-09</th>\n      <td>335.0</td>\n      <td>337.5</td>\n      <td>333.5</td>\n      <td>337.5</td>\n      <td>312.403137</td>\n      <td>31481504</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n### 簡單股票分析\n\n首先我們先輸出所有收盤價比開盤價上漲 $3\\%$ 以上的日期。用數學的方式表達即是\n$$\n\\frac{\\text{Close}_{t} - \\text{Open}_{t}}{\\text{Open}_{t}} > 0.03\n$$\n\n因此我們可以寫下以下程式碼：\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\n(df['Close'] - df['Open']) / df['Open'] > 0.03\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\nDate\n2020-01-02    False\n2020-01-03    False\n2020-01-06    False\n2020-01-07    False\n2020-01-08    False\n              ...  \n2022-12-26    False\n2022-12-27    False\n2022-12-28    False\n2022-12-29    False\n2022-12-30    False\nLength: 734, dtype: bool\n```\n:::\n:::\n\n\n可以發現回傳的值為布林值，因此可以作為行索引(row index)。\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\n# 根據行索引選取並輸出日期\ndf.loc[(df['Close'] - df['Open']) / df['Open'] > 0.03].index\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\nDatetimeIndex(['2020-03-13', '2020-03-20', '2021-01-21', '2022-05-31',\n               '2022-07-07', '2022-11-09', '2022-11-15', '2022-11-22'],\n              dtype='datetime64[ns]', name='Date', freq=None)\n```\n:::\n:::\n\n\n我們即可得知這些日期符合我們的搜尋標準(searching standard)。\n\n如果我們現在將搜尋標準改為輸出所有開盤價比前日收盤價小於 $2\\%$ 的日期，我們可以用 `shift(1)` 來獲取前日的資料。以數學式表達即為\n\n$$\n\\frac{\\text{Open}_{t} - \\text{Close}_{t-1}}{\\text{Close}_{t-1}} < -0.02\n$$\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\n# 根據行索引選取並輸出日期\ndf.loc[(df['Open'] - df['Close'].shift(1)) / df['Close'].shift(1) < -0.02].index\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\nDatetimeIndex(['2020-01-16', '2020-01-30', '2020-02-18', '2020-03-02',\n               '2020-03-09', '2020-03-13', '2020-03-17', '2020-03-19',\n               '2020-03-23', '2020-03-30', '2020-05-04', '2020-05-18',\n               '2020-06-12', '2020-09-04', '2021-01-14', '2021-01-22',\n               '2021-01-28', '2021-02-24', '2021-02-26', '2021-03-04',\n               '2021-03-05', '2021-03-09', '2021-03-24', '2021-05-13',\n               '2021-05-17', '2021-06-21', '2021-07-16', '2021-08-18',\n               '2021-09-22', '2021-09-29', '2022-03-07', '2022-03-08',\n               '2022-03-28', '2022-04-01', '2022-04-27', '2022-05-06',\n               '2022-05-10', '2022-05-19', '2022-06-10', '2022-06-13',\n               '2022-07-04', '2022-08-29', '2022-09-07', '2022-09-14',\n               '2022-09-26', '2022-09-30', '2022-10-11', '2022-10-17',\n               '2022-11-03', '2022-11-28', '2022-12-16', '2022-12-23'],\n              dtype='datetime64[ns]', name='Date', freq=None)\n```\n:::\n:::\n\n\n## 雙均線策略\n\n均線（Moving Average）是一種技術分析工具，常用於股票、外匯和其他金融市場的分析。它是通過計算一段時間內的價格平均值來平滑價格走勢，從而消除價格波動的短期噪音，使得長期趨勢更加清晰可見。\n\n均線的計算很簡單，只需將一段時間內的收盤價相加，然後除以該段時間的天數即可得到均線值。常見的均線包括 5 日均線、10 日均線、20 日均線、50 日均線和 200 日均線等。\n\n不同的均線代表了不同時間範圍的平均價格，長期均線（如 200 日均線）較為平滑，反映了較長時間的趨勢變化，而短期均線（如 5 日均線）較為敏感，更能反映近期價格變動。\n\n均線的計算方式有許多種，大致可以分為以下三類：\n\n1. 簡單移動平均線(simple moving average，SMA)：\n$$\n\\text{MA} = \\frac{1}{n} \\sum_{i=1}^{n} P_i\n$$\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $n$代表計算均線的天數，$P_i$代表第 $i$ 天的價格。\n\n2. 加權移動平均線(weighted moving average，WMA)：\n$$\n\\text{WMA} = \\frac{\\sum_{i=1}^{n} w_i \\cdot P_i}{\\sum_{i=1}^{n} w_i}\n$$\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$w_i$ 代表第 $i$ 天的權重。\n\n3. 指數移動平均線(exponential moving average，EMA)：\n$$\n\\text{EMA}_t = \\alpha \\cdot P_t + (1-\\alpha) \\cdot \\text{EMA}_{t-1}\n$$\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$\\text{EMA}_t$ 代表第 $t$ 天的指數移動平均值，$\\alpha$ 是平滑指數，通常取 $2/(n+1)$，其中 $n$ 為計算均線的天數。\n\n### 求均線方式\n\n假設我們分別要求算收盤價的 5 日均線與 10 日均線，我們可以透過 `rolling()` 與 `mean()` 這兩個函數進行以下操作：\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nma5 = df['Close'].rolling(5).mean()\nma30 = df['Close'].rolling(30).mean()\n```\n:::\n\n\n接著我們利用 `matplotlib` 套件繪製均線。\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\n# 引入套件\nimport matplotlib.pyplot as plt\n%matplotlib inline\n# 繪製均線\nplt.plot(ma5, color = \"#1c39bb\")\nplt.plot(ma30, color = \"#d70062\")\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-13-output-1.png){width=580 height=411}\n:::\n:::\n\n\n### 黃金交叉與死亡交叉\n\n均線常用於分析股價走勢、判斷趨勢的轉折點以及進行交叉分析。當短期均線穿越長期均線時，被稱為「黃金交叉」，被認為是一個多頭信號，暗示著股價可能上漲；相反，當短期均線跌破長期均線時，被稱為「死亡交叉」，是一個空頭信號，暗示著股價可能下跌。我們根據黃金交叉與死亡交叉的定義建立自定義函式：\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\ndef golden_death_cross_strategy(prices, short_window=5, long_window=30):\n    # 計算短期均線和長期均線\n    short_ma = pd.Series(prices).rolling(window=short_window, min_periods=1).mean()\n    long_ma = pd.Series(prices).rolling(window=long_window, min_periods=1).mean()\n\n    # 判斷黃金交叉和死亡交叉\n    signals = pd.Series(0, index=range(len(prices)))  \n    # 交叉信號：0表示無交叉，1表示黃金交叉，-1表示死亡交叉\n    for i in range(1, len(prices)):\n        if short_ma[i] > long_ma[i] and short_ma[i - 1] <= long_ma[i - 1]:\n            signals[i] = 1  # 黃金交叉\n        elif short_ma[i] < long_ma[i] and short_ma[i - 1] >= long_ma[i - 1]:\n            signals[i] = -1  # 死亡交叉\n\n    return signals\n\n# 呼叫函數，得到交叉信號\nclosing_prices = df['Close']\nsignals = golden_death_cross_strategy(closing_prices)\n\n# 輸出交叉信號\nfor i, signal in enumerate(signals):\n    if signal == 1:\n        print(f\"黃金交叉：第 {i+1} 天\")\n    elif signal == -1:\n        print(f\"死亡交叉：第 {i+1} 天\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n死亡交叉：第 6 天\n黃金交叉：第 9 天\n死亡交叉：第 14 天\n黃金交叉：第 25 天\n死亡交叉：第 27 天\n黃金交叉：第 66 天\n死亡交叉：第 89 天\n黃金交叉：第 90 天\n死亡交叉：第 91 天\n黃金交叉：第 100 天\n死亡交叉：第 167 天\n黃金交叉：第 169 天\n死亡交叉：第 179 天\n黃金交叉：第 186 天\n死亡交叉：第 201 天\n黃金交叉：第 206 天\n死亡交叉：第 280 天\n黃金交叉：第 304 天\n死亡交叉：第 313 天\n黃金交叉：第 317 天\n死亡交叉：第 320 天\n黃金交叉：第 339 天\n死亡交叉：第 364 天\n黃金交叉：第 370 天\n死亡交叉：第 375 天\n黃金交叉：第 386 天\n死亡交叉：第 392 天\n黃金交叉：第 403 天\n死亡交叉：第 419 天\n黃金交叉：第 438 天\n死亡交叉：第 465 天\n黃金交叉：第 470 天\n死亡交叉：第 476 天\n黃金交叉：第 486 天\n死亡交叉：第 509 天\n黃金交叉：第 514 天\n死亡交叉：第 515 天\n黃金交叉：第 546 天\n死亡交叉：第 547 天\n黃金交叉：第 584 天\n死亡交叉：第 593 天\n黃金交叉：第 619 天\n死亡交叉：第 647 天\n黃金交叉：第 699 天\n死亡交叉：第 726 天\n```\n:::\n:::\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}
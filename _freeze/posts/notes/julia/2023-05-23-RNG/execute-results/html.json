{
  "hash": "f2bbe27ee98cd4d0340e0b73e1891814",
  "result": {
    "markdown": "---\ntitle: \"Random Numbers and Random Number Generator\"\ndate: \"2023-05-22\"\ncategories: [Julia, programming language, numerical analysis]\nformat:\n  html: \n    code-fold: false\n---\n\nIn social sciences, there are numerous cases of whether we need to use and generate random numbers, or draw random values from distributions.\n\n- drawing from a sample: survey\n- re-sampling: bootstrapping\n- numerical analysis: integration, differentiation\n- simulation: normal distribution\n\n## Is Random Number Truly Random?\n\nWhen we say truly random, these values cannot be repeated. Though it is more precise for the definition of random number, the process of generating random numbers is not reproducible. Therefore, we need pseudo-random numbers, which employs some specific algorithms to generate numbers, and usually requires a seed to recursively generate numbers.\n\n### Random Number Generation vs. Random Number Generator(RNG)\n\nRandom number generation is the process of generating random numbers, while random number generator(RNG) serves a specific algorithm to generate random numbers. Most of time when we do numerical analysis, we use pseudo-random number generator(PRNG) instead of RNG.\n\nIn julia, there are two common algorithms of PRNG.\n\n- Mersenne Twister algorithm\n- xoshiro algorithm\n- Lehmer algorithm\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nusing Random, StableRNGs\n\n## set random number seed\nmyrng1 = MersenneTwister(1234);\nmyrng2 = Xoshiro(1234);\nmyrng3 = StableRNG(1234);\n```\n:::\n\n\n### Put Random Seeds in \"global\" Scope\n\n\"Global\" means it is visible (hence accessible) throughout the program, unless shadowed.\n\n::: {.cell execution_count=2}\n``` {.julia .cell-code}\nusing Random\n\nRandom.seed!(1234)   # use julia's default RNG\nRandom.seed!(myrng1) # use myrng1 as RNG\nRandom.seed!(MersenneTwister(1234)) |> display\nRandom.seed!(myrng1, 5678) # overwrite the seed of myrng1\n```\n\n::: {.cell-output .cell-output-display}\n```\nMersenneTwister(0xb828c8c1fbb278f6a4f15da8fc22f6b0)\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\nMersenneTwister(5678)\n```\n:::\n:::\n\n\nNow that we have set up our RNG, we can apply it to generate some random numbers using `rand()`.\n\n::: {.cell execution_count=3}\n``` {.julia .cell-code}\nusing Random\n\nRandom.seed!(1234)\n\na1 = rand(4)\na2 = rand(4, 1)\na3 = rand(4, 2)\na4 = randn(4, 3)\n\n@show a1\n@show a2\n@show a3\n@show a4\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na1 = [0.32597672886359486, 0.5490511363155669, 0.21858665481883066, 0.8942454282009883]\na2 = [0.35311164439921205; 0.39425536741585077; 0.9531246272848422; 0.7955469475347194;;]\na3 = [0.20516767351768161 0.1108168569969088; 0.5271837562207654 0.8200194245990075; 0.9511618942933061 0.525905572135954; 0.07399570839268677 0.12382309152735982]\na4 = [-0.009912716387820018 1.3121527759884466 1.0008454162742852; -0.23719674111345168 0.41640781370296154 0.11808763612684553; -0.23404691711725342 -0.13721401795601826 -0.6692081956254178; 1.2082144774406498 0.04716833667239948 -1.8716115327144618]\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n4Ã—3 Matrix{Float64}:\n -0.00991272   1.31215     1.00085\n -0.237197     0.416408    0.118088\n -0.234047    -0.137214   -0.669208\n  1.20821      0.0471683  -1.87161\n```\n:::\n:::\n\n\nNote that we can recognise RNG as a stopwatch. When the programme has finished generating some random numbers, the stopwatch will stop and reset. Hence you can check the result if you put another RNG before `a1` and see whether the result would be the same as what `a1` was.[^1]\n\n[^1]: The answer is no, obviously. Therefore, that's the reason why we need to put `Random.seed!(1234)` in our script.\n\nYou might think what is the difference between `a1` and `a2`. We can use `size()` and `typeof()` to check.\n\n::: {.cell execution_count=4}\n``` {.julia .cell-code}\n@show a1\n@show a2\n\n# See the dim of a1 and a2\n@show size(a1)\n@show size(a2)\n\n# Check the type of a1 and a2\n@show typeof(a1)\n@show typeof(a2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na1 = [0.32597672886359486, 0.5490511363155669, 0.21858665481883066, 0.8942454282009883]\na2 = [0.35311164439921205; 0.39425536741585077; 0.9531246272848422; 0.7955469475347194;;]\nsize(a1) = (4,)\nsize(a2) = (4, 1)\ntypeof(a1) = Vector{Float64}\ntypeof(a2) = Matrix{Float64}\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=5}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre>Matrix{Float64}<span class=\"ansi-bright-black-fg\"> (alias for </span><span class=\"ansi-bright-black-fg\">Array{Float64, 2}</span><span class=\"ansi-bright-black-fg\">)</span></pre>\n```\n:::\n\n:::\n:::\n\n\n",
    "supporting": [
      "2023-05-23-RNG_files"
    ],
    "filters": [],
    "includes": {}
  }
}
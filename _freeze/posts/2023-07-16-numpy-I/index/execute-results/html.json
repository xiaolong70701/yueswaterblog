{
  "hash": "831331166c63775646d5171111a3750f",
  "result": {
    "markdown": "---\ntitle: \"NumPy 筆記（一）\"\nimage: coding preview.png\ndate: \"2023-07-16\"\ndescription: 多功能的數值計算與數據處理套件。\ncategories: [R, Quarto, programming language]\nformat:\n  html: \n    code-fold: false\n---\n\n> *NumPy is an open source project that enables numerical computing with Python.*\n\n`NumPy`(Numerical Python) 是由T ravis Olliphant 於2005年創建的開源數值計算庫。它是 Python 科學計算生態系統中最重要的基礎庫之一。`NumPy` 提供了一個高效的多維數組對象和用於處理數組數據的各種函數和工具，更多內容請參考[`NumPy` 官方網站](https://`NumPy`.org)。`NumPy` 的優點如下：\n\n1. **強大的數組操作功能**：`NumPy`提供了廣泛的數組操作功能，包括數組索引(indexing)、切片(slicing)、向量化(Vectorization)運算等。\n\n2. **高性能的數值計算**：`NumPy` 的底層結構是由 `C` 語言編寫的，因此在處理大規模數據集時具有出色、高效的性能，其中的許多函數和操作都經過優化，能夠高效地執行數值計算任務。\n\n3. **豐富的數學函數庫**：其提供了許多常用的數學函數，如三角函數、指數函數、對數函數、線性代數運算、傅里葉變換等。這些函數能夠方便地在數組上進行操作。\n\n4. **與其他科學計算庫的兼容性**：`NumPy` 是許多其他科學計算庫的基礎，包括 `SciPy`、`Pandas` 和 `Matplotlib` 等。它們都建立在`NumPy`的數組對象之上，因此能夠無縫地與`NumPy`進行集成和互操作。\n\n儘管`NumPy`有許多優點，但也存在一些缺點：\n\n1. **相對較高的學習曲線**：對於初學者來說，`NumPy`的一些概念和操作可能需要一些時間和努力才能理解和掌握。特別是對於那些沒有背景知識的人來說，使用`NumPy`可能需要一些學習成本。\n\n2. **較大的內存占用**：`NumPy`數組需要在內存中連續存儲數據，這可能導致較大的內存占用。當處理非常大的數組時，內存消耗可能會成為一個挑戰。\n\n總體而言，`NumPy`是一個強大而廣泛應用的數值計算庫，為 Python 用戶提供了處理數組數據和執行數值計算的基礎設施，尤其是在這個資料科學世代，Numpy 提供了數據科學家與資料科學家一個更有效率的工具。\n\n## 安裝 NumPy 與匯入套件\n\n以下的安裝方式是參考[官方網站](https://numpy.org/install/)的指示。如果使用的是 `conda`，可以使用下列方式下載：\n\n```python\n# Best practice, use an environment rather than install in the base env\nconda create -n my-env\nconda activate my-env\n# If you want to install from conda-forge\nconda config --env --add channels conda-forge\n# The actual install command\nconda install numpy\n```\n\n若要用 `pip` 安裝，則在終端機或命令提示字元輸入：\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\npip install numpy\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRequirement already satisfied: numpy in /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages (1.24.3)\r\n\r\n[notice] A new release of pip is available: 23.1.2 -> 23.2\r\n[notice] To update, run: pip install --upgrade pip\r\nNote: you may need to restart the kernel to use updated packages.\n```\n:::\n:::\n\n\n安裝完畢後我們就可以執行下列程式碼匯入 NumPy 套件：\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nimport numpy as np\n```\n:::\n\n\n注意到我們可以用 `import [package name] as [short name]` 來將套件在專案中重新命名，目的是為了節省打字時間與簡化排版。\n\n## 陣列與矩陣\n\n陣列和矩陣在使用 `Python` 進行量化交易中扮演著重要的角色，它除了能夠儲存資料外，我們也可以使用線性代數(linear algebra)的概念與工具處理陣列與矩陣，加速我們的計算，以及使我們的計算更加精確與有效率。\n\n- 數據結構：陣列和矩陣提供了有效的數據結構來存儲和操作大量的數值數據。在量化交易中，我們需要處理大量的歷史股價、指標數據和交易信號等數據。使用陣列和矩陣可以高效地存儲和操作這些數據，從而加速數據處理和分析的過程。\n\n- 數據處理和計算：陣列和矩陣提供了豐富的數學運算和統計函數，可以進行向量化計算和數據處理。在量化交易中，我們經常需要進行指標計算、風險管理、投資組合優化等數學計算。使用陣列和矩陣可以方便地應用這些數學函數，並且能夠高效地處理大量的數據。\n\n- 高效的算法實現：陣列和矩陣操作可以利用底層的 `C` 語言實現，從而提供了高效的計算性能。在量化交易中（尤其是高頻交易），速度是關鍵因素之一。使用陣列和矩陣可以通過向量化計算和並行處理來提高算法的執行速度，從而實現更快的回測和交易執行。\n\n- 數據可視化：陣列和矩陣可以與其他數據可視化庫（如 `Matplotlib`）結合使用，以生成交易策略的圖表和可視化結果。這對於量化交易的分析和策略驗證非常重要，能夠幫助交易員更好地理解數據和模型的結果。\n\n### 陣列(Arrays)\n\n陣列其實可以對應到線性代數中的純量(scalars)，但在 `NumPy` 套件中稱為陣列，因此我們沿用此套件的名稱避免混淆。以下我們將會針對陣列的建立、運算與取值等進行說明。\n\n#### 建立陣列\n\n我們可以使用 `NumPy` 來建立陣列，以下是一些建立陣列的常見方法：\n\n- `np.array()`：將 Python 列表或元組轉換為 `NumPy` 陣列。\n- `np.zeros()`：建立元素全為 $0$ 的陣列。\n- `np.ones()`：建立元素全為 $1$ 的陣列。\n- `np.arange()`：建立連續數字的陣列。\n- `np.linspace()`：建立指定範圍內均勻分布的陣列。\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\n# 使用np.array()建立陣列\narr1 = np.array([1, 2, 3, 4, 5])\nprint(arr1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1 2 3 4 5]\n```\n:::\n:::\n\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\n# 使用np.zeros()建立元素全為0的陣列\narr2 = np.zeros(5)\nprint(arr2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0. 0. 0. 0. 0.]\n```\n:::\n:::\n\n\n一般來說，建立元素全部為 $0$ 的陣列是一個技巧性的操作，目的是為了減少使用迴圈執行時所消耗的記憶體。更精確地說，假設我們在執行蒙地卡羅模擬(Monte Carlo simulation)，想要將新的值放進陣列中，如果我們已經知道會有 $n$ 個值，則建立一個長度為 $n$ 的陣列，用迴圈將值代入即可，將可以避免使用 `append()` 函數——因爲 `append()` 函數在迴圈執行時會重新計算陣列長度，將會消耗記憶體，且會浪費時間。\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\n# 使用np.ones()建立元素全為1的陣列\narr3 = np.ones(5)\nprint(arr3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1. 1. 1. 1. 1.]\n```\n:::\n:::\n\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\n# 使用np.arange()建立連續數字的陣列\narr4 = np.arange(1, 6)\nprint(arr4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1 2 3 4 5]\n```\n:::\n:::\n\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\n# 使用np.linspace()建立指定範圍內均勻分布的陣列\narr5 = np.linspace(0, 1, 5)\nprint(arr5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0.   0.25 0.5  0.75 1.  ]\n```\n:::\n:::\n\n\n特別說明一下 `np.linspace()`，函數內第一個參數是區間的下界，第二個則是上界，最後一個則是要以多少步長(step)切分這個區間。例如上面給的例子為 $[0, 1]$，並將該區間切成 $5$ 份。\n\n#### 索引陣列\n\n陣列中的元素可以通過索引來進行取值或更改值。在 `NumPy` 中，陣列的索引從 $0$ 開始，使用中括號 `[]` 進行索引。\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\narr = np.array([1, 2, 3, 4, 5])\n\n# 獲取單個元素\nprint(arr[0])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1\n```\n:::\n:::\n\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\n# 修改元素值\narr[1] = 10\nprint(arr)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[ 1 10  3  4  5]\n```\n:::\n:::\n\n\n#### 取值與切片\n\n在 `NumPy` 中，我們可以使用索引和切片來獲取陣列中的特定元素或子陣列。\n\n- 取值：通過索引獲取單個元素的值。\n- 切片：通過指定起始索引和結束索引獲取子陣列。\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\narr = np.array([1, 2, 3, 4, 5])\n```\n:::\n\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\n# 取值\nprint(arr[-1])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n5\n```\n:::\n:::\n\n\n注意到如果要取最後一個值，則使用 `[-1]`，代表從後面開始計算的第一個值。\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\n# 切片\nprint(arr[1:4])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[2 3 4]\n```\n:::\n:::\n\n\n如果我們要從後面開始取值，則使用負數代表從後面開始。例如想要取倒數兩個值，則使用下列方式：\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\nprint(arr[-2:])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[4 5]\n```\n:::\n:::\n\n\n注意到 `arr[-1]` 與 `arr[-1:]` 的結果是相同的。 \n\n#### 陣列運算\n\n`NumPy` 提供了豐富的數學函數和運算符，可以對陣列進行各種數學運算。\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\narr1 = np.array([1, 2, 3])\narr2 = np.array([4, 5, 6])\n```\n:::\n\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\n# 加法\nprint(arr1 + arr2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[5 7 9]\n```\n:::\n:::\n\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\n# 減法\nprint(arr2 - arr1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[3 3 3]\n```\n:::\n:::\n\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\n# 乘法\nprint(arr1 * arr2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[ 4 10 18]\n```\n:::\n:::\n\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\n# 除法\nprint(arr2 / arr1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[4.  2.5 2. ]\n```\n:::\n:::\n\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\n# 平方\nprint(arr1 ** 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1 4 9]\n```\n:::\n:::\n\n\n### 矩陣(Matrices)\n\n除了陣列，`NumPy` 還提供了矩陣的功能。一個 $m \\times n$ 的矩陣代表有 $m$ 列(row)與 $n$ 行(column)元素的矩形陣列，元素可以是符號、數字、函數等。\n$$\n{\\displaystyle {\\begin{bmatrix}a_{11}&a_{12}&a_{13}&\\dots &a_{1j}&\\dots &a_{1n}\\\\a_{21}&a_{22}&a_{23}&\\dots &a_{2j}&\\dots &a_{2n}\\\\a_{31}&a_{32}&a_{33}&\\dots &a_{3j}&\\dots &a_{3n}\\\\\\vdots &\\vdots &\\vdots &\\ddots &\\vdots &\\ddots &\\vdots \\\\a_{i1}&a_{i2}&a_{i3}&\\dots &a_{ij}&\\dots &a_{in}\\\\\\vdots &\\vdots &\\vdots &\\ddots &\\vdots &\\ddots &\\vdots \\\\a_{m1}&a_{m2}&a_{m3}&\\dots &a_{mj}&\\dots &a_{mn}\\end{bmatrix}}}\n$$\n\n#### 建立矩陣\n\n我們可以使用 NumPy 來建立矩陣，以下是一些建立矩陣的常見方法：\n\n- `np.array()`：將二維列表或元組轉換為 `NumPy` 矩陣。\n- `np.zeros()`：建立元素全為0的矩陣。\n- `np.ones()`：建立元素全為1的矩陣。\n\n下面是一些範例：\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\n# 使用np.array()建立矩陣\nmatrix1 = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nprint(matrix1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1 2 3]\n [4 5 6]\n [7 8 9]]\n```\n:::\n:::\n\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\n# 使用np.zeros()建立元素全為0的矩陣\nmatrix2 = np.zeros((3, 3))\nprint(matrix2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[0. 0. 0.]\n [0. 0. 0.]\n [0. 0. 0.]]\n```\n:::\n:::\n\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\n# 使用np.ones()建立元素全為1的矩陣\nmatrix3 = np.ones((2, 2))\nprint(matrix3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1. 1.]\n [1. 1.]]\n```\n:::\n:::\n\n\n#### 索引矩陣\n\n矩陣中的元素可以通過索引來訪問和操作，與陣列類似。在二維矩陣中，可以\n\n使用行和列的索引進行訪問。\n\n下面是一些範例：\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\nmatrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n```\n:::\n\n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\n# 獲取單個元素\nprint(matrix[0, 1])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2\n```\n:::\n:::\n\n\n::: {.cell execution_count=25}\n``` {.python .cell-code}\n# 修改元素值\nmatrix[1, 2] = 10\nprint(matrix)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[ 1  2  3]\n [ 4  5 10]\n [ 7  8  9]]\n```\n:::\n:::\n\n\n#### 取值與切片\n\n與陣列相似，我們可以使用索引和切片來獲取矩陣中的特定元素或子矩陣。下面是一些範例：\n\n::: {.cell execution_count=26}\n``` {.python .cell-code}\nmatrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n```\n:::\n\n\n::: {.cell execution_count=27}\n``` {.python .cell-code}\n# 取值\nprint(matrix[1, 2])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n6\n```\n:::\n:::\n\n\n::: {.cell execution_count=28}\n``` {.python .cell-code}\n# 切片\nprint(matrix[0:2, 1:3])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[2 3]\n [5 6]]\n```\n:::\n:::\n\n\n#### 矩陣運算\n\n使用`+`運算符可以對兩個矩陣進行相加，使用`-`運算符可以對兩個矩陣進行相減。請確保兩個矩陣具有相同的形狀。\n\n::: {.cell execution_count=29}\n``` {.python .cell-code}\n# 加法\nmatrix1 = np.array([[1, 2], [3, 4]])\nmatrix2 = np.array([[5, 6], [7, 8]])\nresult = matrix1 + matrix2\n```\n:::\n\n\n使用`@`運算符或者`np.dot()`函數可以進行矩陣乘法。請確保第一個矩陣的列數等於第二個矩陣的行數。\n\n::: {.cell execution_count=30}\n``` {.python .cell-code}\n# 乘法\nmatrix1 = np.array([[1, 2], [3, 4]])\nmatrix2 = np.array([[5, 6], [7, 8]])\nresult = matrix1 @ matrix2\n# 或者使用 np.dot(matrix1, matrix2)\n```\n:::\n\n\n使用`.T`屬性可以獲取矩陣的轉置。\n\n::: {.cell execution_count=31}\n``` {.python .cell-code}\n# 求轉置矩陣\nmatrix = np.array([[1, 2], [3, 4]])\ntransposed_matrix = matrix.T\n```\n:::\n\n\n使用`np.linalg.inv()`函數可以求一個可逆矩陣的反矩陣。\n\n::: {.cell execution_count=32}\n``` {.python .cell-code}\n# 求反矩陣\nmatrix = np.array([[1, 2], [3, 4]])\ninverse_matrix = np.linalg.inv(matrix)\n```\n:::\n\n\n使用`np.linalg.det()`函數可以計算矩陣的行列式值。\n\n::: {.cell execution_count=33}\n``` {.python .cell-code}\n# 求行列式值\nmatrix = np.array([[1, 2], [3, 4]])\ndeterminant = np.linalg.det(matrix)\n```\n:::\n\n\nｓ\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}